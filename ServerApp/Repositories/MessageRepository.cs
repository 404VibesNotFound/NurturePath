// Generated by Copilot - September 1, 2025 at 12:30 PM
using Microsoft.EntityFrameworkCore;
using ServerApp.Data;
using ServerApp.Data.DTOs;
using ServerApp.Data.Models;

namespace ServerApp.Repositories
{
    /// <summary>
    /// Repository implementation for message operations
    /// Handles secure messaging with role-based access control
    /// </summary>
    public class MessageRepository : IMessageRepository
    {
        private readonly DatabaseContext _context;

        public MessageRepository(DatabaseContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Send a new message
        /// </summary>
        public async Task<Message> SendMessage(int senderId, SendMessageRequest request)
        {
            var sender = await _context.Users.FindAsync(senderId);
            if (sender == null)
                throw new UnauthorizedAccessException("Sender not found");

            // Check if sender can message the receiver
            if (!await CanSendMessageTo(senderId, request.ReceiverId))
                throw new UnauthorizedAccessException("Not authorized to send message to this user");

            var threadId = GenerateThreadId(senderId, request.ReceiverId);

            var message = new Message
            {
                SenderId = senderId,
                ReceiverId = request.ReceiverId,
                Subject = request.Subject,
                Content = request.Content,
                Priority = request.Priority,
                ThreadId = threadId,
                SentAt = DateTime.UtcNow,
                IsArchived = false
            };

            _context.Messages.Add(message);
            await _context.SaveChangesAsync();

            // Add read status for sender (mark as read)
            var senderReadStatus = new MessageReadStatus
            {
                MessageId = message.Id,
                UserId = senderId,
                ReadAt = DateTime.UtcNow
            };
            _context.MessageReadStatuses.Add(senderReadStatus);

            // Handle attachments if any
            if (request.Attachments?.Any() == true)
            {
                foreach (var attachment in request.Attachments)
                {
                    var messageAttachment = new MessageAttachment
                    {
                        MessageId = message.Id,
                        FileName = attachment.FileName,
                        FileSize = attachment.FileSize,
                        FileType = attachment.FileType,
                        FileContent = attachment.FileContent,
                        UploadedAt = DateTime.UtcNow
                    };
                    _context.MessageAttachments.Add(messageAttachment);
                }
            }

            await _context.SaveChangesAsync();
            return message;
        }

        /// <summary>
        /// Get all conversations for a user
        /// </summary>
        public async Task<List<ConversationResponse>> GetConversations(int userId)
        {
            // Get distinct thread IDs where user is either sender or receiver
            var threadIds = await _context.Messages
                .Where(m => (m.SenderId == userId || m.ReceiverId == userId) && !m.IsArchived)
                .Select(m => m.ThreadId)
                .Distinct()
                .ToListAsync();

            var conversations = new List<ConversationResponse>();

            foreach (var threadId in threadIds)
            {
                // Get the latest message in each thread
                var latestMessage = await _context.Messages
                    .Where(m => m.ThreadId == threadId)
                    .OrderByDescending(m => m.SentAt)
                    .Include(m => m.Sender)
                    .Include(m => m.Receiver)
                    .FirstOrDefaultAsync();

                if (latestMessage != null)
                {
                    // Determine the other participant
                    var otherUser = latestMessage.SenderId == userId 
                        ? latestMessage.Receiver 
                        : latestMessage.Sender;

                    // Count unread messages in this thread for current user
                    var unreadCount = await _context.Messages
                        .Where(m => m.ThreadId == threadId && m.ReceiverId == userId)
                        .Where(m => !_context.MessageReadStatuses
                            .Any(rs => rs.MessageId == m.Id && rs.UserId == userId))
                        .CountAsync();

                    conversations.Add(new ConversationResponse
                    {
                        ThreadId = threadId,
                        OtherParticipant = $"{otherUser.FirstName} {otherUser.LastName}",
                        OtherParticipantRole = otherUser.Role.ToString(),
                        LastMessageContent = latestMessage.Content,
                        LastMessageTime = latestMessage.SentAt,
                        UnreadCount = unreadCount,
                        Priority = latestMessage.Priority
                    });
                }
            }

            return conversations.OrderByDescending(c => c.LastMessageTime).ToList();
        }

        /// <summary>
        /// Get messages in a specific thread
        /// </summary>
        public async Task<List<MessageResponse>> GetMessagesInThread(string threadId, int userId)
        {
            // Check if user has access to this thread
            var hasAccess = await _context.Messages
                .AnyAsync(m => m.ThreadId == threadId && (m.SenderId == userId || m.ReceiverId == userId));

            if (!hasAccess)
                throw new UnauthorizedAccessException("Not authorized to access this thread");

            var messages = await _context.Messages
                .Where(m => m.ThreadId == threadId && !m.IsArchived)
                .Include(m => m.Sender)
                .Include(m => m.Receiver)
                .Include(m => m.Attachments)
                .Include(m => m.ReadStatuses)
                .OrderBy(m => m.SentAt)
                .ToListAsync();

            return messages.Select(m => new MessageResponse
            {
                Id = m.Id,
                SenderId = m.SenderId,
                SenderName = $"{m.Sender.FirstName} {m.Sender.LastName}",
                SenderRole = m.Sender.Role.ToString(),
                ReceiverId = m.ReceiverId,
                ReceiverName = $"{m.Receiver.FirstName} {m.Receiver.LastName}",
                Subject = m.Subject,
                Content = m.Content,
                Priority = m.Priority,
                ThreadId = m.ThreadId,
                SentAt = m.SentAt,
                IsRead = m.ReadStatuses.Any(rs => rs.UserId == userId),
                ReadAt = m.ReadStatuses.FirstOrDefault(rs => rs.UserId == userId)?.ReadAt,
                Attachments = m.Attachments.Select(a => new AttachmentDto
                {
                    Id = a.Id,
                    FileName = a.FileName,
                    FileSize = a.FileSize,
                    FileType = a.FileType,
                    UploadedAt = a.UploadedAt
                }).ToList()
            }).ToList();
        }

        /// <summary>
        /// Get message by ID
        /// </summary>
        public async Task<MessageResponse?> GetMessage(int messageId, int userId)
        {
            var message = await _context.Messages
                .Include(m => m.Sender)
                .Include(m => m.Receiver)
                .Include(m => m.Attachments)
                .Include(m => m.ReadStatuses)
                .FirstOrDefaultAsync(m => m.Id == messageId);

            if (message == null || (message.SenderId != userId && message.ReceiverId != userId))
                return null;

            return new MessageResponse
            {
                Id = message.Id,
                SenderId = message.SenderId,
                SenderName = $"{message.Sender.FirstName} {message.Sender.LastName}",
                SenderRole = message.Sender.Role.ToString(),
                ReceiverId = message.ReceiverId,
                ReceiverName = $"{message.Receiver.FirstName} {message.Receiver.LastName}",
                Subject = message.Subject,
                Content = message.Content,
                Priority = message.Priority,
                ThreadId = message.ThreadId,
                SentAt = message.SentAt,
                IsRead = message.ReadStatuses.Any(rs => rs.UserId == userId),
                ReadAt = message.ReadStatuses.FirstOrDefault(rs => rs.UserId == userId)?.ReadAt,
                Attachments = message.Attachments.Select(a => new AttachmentDto
                {
                    Id = a.Id,
                    FileName = a.FileName,
                    FileSize = a.FileSize,
                    FileType = a.FileType,
                    UploadedAt = a.UploadedAt
                }).ToList()
            };
        }

        /// <summary>
        /// Mark message as read
        /// </summary>
        public async Task<bool> MarkMessageAsRead(int messageId, int userId)
        {
            var message = await _context.Messages.FindAsync(messageId);
            if (message == null || message.ReceiverId != userId)
                return false;

            // Check if already marked as read
            var existingReadStatus = await _context.MessageReadStatuses
                .FirstOrDefaultAsync(rs => rs.MessageId == messageId && rs.UserId == userId);

            if (existingReadStatus == null)
            {
                var readStatus = new MessageReadStatus
                {
                    MessageId = messageId,
                    UserId = userId,
                    ReadAt = DateTime.UtcNow
                };
                _context.MessageReadStatuses.Add(readStatus);
                await _context.SaveChangesAsync();
            }

            return true;
        }

        /// <summary>
        /// Archive a message
        /// </summary>
        public async Task<bool> ArchiveMessage(int messageId, int userId)
        {
            var message = await _context.Messages.FindAsync(messageId);
            if (message == null || (message.SenderId != userId && message.ReceiverId != userId))
                return false;

            message.IsArchived = true;
            await _context.SaveChangesAsync();
            return true;
        }

        /// <summary>
        /// Search messages
        /// </summary>
        public async Task<MessageSearchResponse> SearchMessages(int userId, MessageSearchRequest searchRequest)
        {
            var query = _context.Messages
                .Where(m => (m.SenderId == userId || m.ReceiverId == userId) && !m.IsArchived)
                .Include(m => m.Sender)
                .Include(m => m.Receiver)
                .AsQueryable();

            // Apply filters
            if (!string.IsNullOrEmpty(searchRequest.Query))
            {
                query = query.Where(m => 
                    m.Subject.Contains(searchRequest.Query) || 
                    m.Content.Contains(searchRequest.Query));
            }

            if (searchRequest.FromUserId.HasValue)
            {
                query = query.Where(m => m.SenderId == searchRequest.FromUserId.Value);
            }

            if (searchRequest.Priority.HasValue)
            {
                query = query.Where(m => m.Priority == searchRequest.Priority.Value);
            }

            if (searchRequest.StartDate.HasValue)
            {
                query = query.Where(m => m.SentAt >= searchRequest.StartDate.Value);
            }

            if (searchRequest.EndDate.HasValue)
            {
                query = query.Where(m => m.SentAt <= searchRequest.EndDate.Value);
            }

            if (searchRequest.IsRead.HasValue)
            {
                if (searchRequest.IsRead.Value)
                {
                    query = query.Where(m => _context.MessageReadStatuses
                        .Any(rs => rs.MessageId == m.Id && rs.UserId == userId));
                }
                else
                {
                    query = query.Where(m => !_context.MessageReadStatuses
                        .Any(rs => rs.MessageId == m.Id && rs.UserId == userId));
                }
            }

            var totalCount = await query.CountAsync();

            // Apply pagination
            var messages = await query
                .OrderByDescending(m => m.SentAt)
                .Skip((searchRequest.Page - 1) * searchRequest.PageSize)
                .Take(searchRequest.PageSize)
                .ToListAsync();

            return new MessageSearchResponse
            {
                Messages = messages.Select(m => new MessageResponse
                {
                    Id = m.Id,
                    SenderId = m.SenderId,
                    SenderName = $"{m.Sender.FirstName} {m.Sender.LastName}",
                    SenderRole = m.Sender.Role.ToString(),
                    ReceiverId = m.ReceiverId,
                    ReceiverName = $"{m.Receiver.FirstName} {m.Receiver.LastName}",
                    Subject = m.Subject,
                    Content = m.Content,
                    Priority = m.Priority,
                    ThreadId = m.ThreadId,
                    SentAt = m.SentAt,
                    IsRead = m.ReadStatuses.Any(rs => rs.UserId == userId),
                    ReadAt = m.ReadStatuses.FirstOrDefault(rs => rs.UserId == userId)?.ReadAt
                }).ToList(),
                TotalCount = totalCount,
                Page = searchRequest.Page,
                PageSize = searchRequest.PageSize,
                TotalPages = (int)Math.Ceiling((double)totalCount / searchRequest.PageSize)
            };
        }

        /// <summary>
        /// Get user's authorized contacts (providers/patients they can message)
        /// </summary>
        public async Task<List<User>> GetAuthorizedContacts(int userId)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null) return new List<User>();

            var contacts = new List<User>();

            if (user.Role == UserRole.Patient)
            {
                // Patients can message their providers and family members with access
                var providerIds = await _context.PatientProviderRelationships
                    .Where(ppr => ppr.PatientId == userId && ppr.IsActive)
                    .Select(ppr => ppr.ProviderId)
                    .ToListAsync();

                var providers = await _context.Users
                    .Where(u => providerIds.Contains(u.Id))
                    .ToListAsync();

                var familyIds = await _context.FamilyAccesses
                    .Where(fa => fa.PatientId == userId && fa.IsActive)
                    .Select(fa => fa.FamilyMemberId)
                    .ToListAsync();

                var familyMembers = await _context.Users
                    .Where(u => familyIds.Contains(u.Id))
                    .ToListAsync();

                contacts.AddRange(providers);
                contacts.AddRange(familyMembers);
            }
            else if (user.Role == UserRole.Provider)
            {
                // Providers can message their patients and other providers
                var patientIds = await _context.PatientProviderRelationships
                    .Where(ppr => ppr.ProviderId == userId && ppr.IsActive)
                    .Select(ppr => ppr.PatientId)
                    .ToListAsync();

                var patients = await _context.Users
                    .Where(u => patientIds.Contains(u.Id))
                    .ToListAsync();

                // Get other providers in the same system (simplified - in real app might be organization-based)
                var otherProviders = await _context.Users
                    .Where(u => u.Role == UserRole.Provider && u.Id != userId)
                    .ToListAsync();

                contacts.AddRange(patients);
                contacts.AddRange(otherProviders);
            }
            else if (user.Role == UserRole.Family)
            {
                // Family members can message patients they have access to and their providers
                var patientIds = await _context.FamilyAccesses
                    .Where(fa => fa.FamilyMemberId == userId && fa.IsActive)
                    .Select(fa => fa.PatientId)
                    .ToListAsync();

                var patients = await _context.Users
                    .Where(u => patientIds.Contains(u.Id))
                    .ToListAsync();

                // Get providers of these patients
                var providerIds = await _context.PatientProviderRelationships
                    .Where(ppr => patientIds.Contains(ppr.PatientId) && ppr.IsActive)
                    .Select(ppr => ppr.ProviderId)
                    .Distinct()
                    .ToListAsync();

                var providers = await _context.Users
                    .Where(u => providerIds.Contains(u.Id))
                    .ToListAsync();

                contacts.AddRange(patients);
                contacts.AddRange(providers);
            }

            return contacts.Distinct().ToList();
        }

        /// <summary>
        /// Check if user can send message to another user
        /// </summary>
        public async Task<bool> CanSendMessageTo(int senderId, int receiverId)
        {
            if (senderId == receiverId) return false;

            var sender = await _context.Users.FindAsync(senderId);
            var receiver = await _context.Users.FindAsync(receiverId);

            if (sender == null || receiver == null) return false;

            // Check based on roles and relationships
            if (sender.Role == UserRole.Patient)
            {
                if (receiver.Role == UserRole.Provider)
                {
                    // Patient can message their providers
                    return await _context.PatientProviderRelationships
                        .AnyAsync(ppr => ppr.PatientId == senderId && ppr.ProviderId == receiverId && ppr.IsActive);
                }
                else if (receiver.Role == UserRole.Family)
                {
                    // Patient can message family members with access
                    return await _context.FamilyAccesses
                        .AnyAsync(fa => fa.PatientId == senderId && fa.FamilyMemberId == receiverId && fa.IsActive);
                }
            }
            else if (sender.Role == UserRole.Provider)
            {
                if (receiver.Role == UserRole.Patient)
                {
                    // Provider can message their patients
                    return await _context.PatientProviderRelationships
                        .AnyAsync(ppr => ppr.ProviderId == senderId && ppr.PatientId == receiverId && ppr.IsActive);
                }
                else if (receiver.Role == UserRole.Provider)
                {
                    // Providers can message other providers (simplified)
                    return true;
                }
                else if (receiver.Role == UserRole.Family)
                {
                    // Provider can message family members of their patients
                    var providerPatientIds = await _context.PatientProviderRelationships
                        .Where(ppr => ppr.ProviderId == senderId && ppr.IsActive)
                        .Select(ppr => ppr.PatientId)
                        .ToListAsync();

                    return await _context.FamilyAccesses
                        .AnyAsync(fa => providerPatientIds.Contains(fa.PatientId) && 
                                       fa.FamilyMemberId == receiverId && fa.IsActive);
                }
            }
            else if (sender.Role == UserRole.Family)
            {
                if (receiver.Role == UserRole.Patient)
                {
                    // Family member can message patients they have access to
                    return await _context.FamilyAccesses
                        .AnyAsync(fa => fa.FamilyMemberId == senderId && fa.PatientId == receiverId && fa.IsActive);
                }
                else if (receiver.Role == UserRole.Provider)
                {
                    // Family member can message providers of patients they have access to
                    var familyPatientIds = await _context.FamilyAccesses
                        .Where(fa => fa.FamilyMemberId == senderId && fa.IsActive)
                        .Select(fa => fa.PatientId)
                        .ToListAsync();

                    return await _context.PatientProviderRelationships
                        .AnyAsync(ppr => familyPatientIds.Contains(ppr.PatientId) && 
                                        ppr.ProviderId == receiverId && ppr.IsActive);
                }
            }

            return false;
        }

        /// <summary>
        /// Generate or get existing thread ID for two users
        /// </summary>
        public string GenerateThreadId(int user1Id, int user2Id)
        {
            // Create consistent thread ID regardless of who initiates
            var minId = Math.Min(user1Id, user2Id);
            var maxId = Math.Max(user1Id, user2Id);
            return $"thread_{minId}_{maxId}";
        }
    }
}
